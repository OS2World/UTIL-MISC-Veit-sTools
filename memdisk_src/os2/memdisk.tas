; Veit Kannegieser 2001.12.22

Title                   Memory emulated DASD adapter for system boot

                        .486p
                        locals @@

                        include build.cfg

data                    Segment 'DATA' Use16 Public
data                    ends
code                    Segment 'CODE' Use16 Public
code                    ends

;********************************************************************

data                    Segment
                       ;assume cs:code
                        assume ds:data

                        include iorb.inc
                        include mbios.inc
                        include devcmd.inc
                        include devhdr.inc
                        include devhlp.inc
                        include mac1.inc
                        include def1.inc
                        include def2.inc

memdisk_add_workspace   Struc
  disk_position         dd ?                    ; current physical "seek" position
memdisk_add_workspace   EndS

;様様様様様様様様様様様様様様様様様様様様様様様様様様様様様様様様様様

                        dd -1
                        dw DEV_CHAR_DEV+DEVLEV_3
                        dw Offset memdisk_strategy
                        dw NULL
                        db 'MEM$DISK'
                        dw 4 dup (0)
                        dd DEV_ADAPTER_DD+DEV_16MB      ; adapter device driver, >16MB address

;様様様様様様様様様様様様様様様様様様様様様様様様様様様様様様様様様様

Device_Help             dd ?
                        Public Device_Help

CommandCode             dw function_unknown     ; 0
                        dw function_CONFIGURATION
                        dw function_UNIT_CONTROL
                        dw function_GEOMETRY
                        dw function_EXECUTE_IO
                        dw function_unknown     ; IOCC_FORMAT
                        dw function_UNIT_STATUS
                        dw function_DEVICE_CONTROL
CommandCode_High        equ IOCC_DEVICE_CONTROL
                        ; not implemented:
                        ; IOCC_ADAPTER_PASSTHRU
                        ; IOCC_RESOURCE
                        Public CommandCode


EXECUTE_IO              dw function_unknown     ; 0
                        dw function_READ
                        dw function_VERIFY
                        dw function_unknown     ; prefetch
                        dw function_WRITE
                        dw function_WRITE       ; WRITE_VERIFY
EXECUTE_IO_High         equ IOCM_WRITE_VERIFY
                        Public EXECUTE_IO

physical_address        dd ?
anzahl_sektoren_je_spur dd 32
anzahl_koepfe           dd 4
anzahl_zylinder         dd 100
anzahl_sektoren         dd ?
                        Public physical_address,anzahl_sektoren_je_spur,anzahl_koepfe,anzahl_zylinder,anzahl_sektoren

disk_GDT                dw 0                    ; "disk" access
dmd_GDT                 dw 0                    ; .DMD buffer access
                        Public disk_GDT,dmd_GDT

ADDDHandle              dw ?
                        Public ADDDHandle

my_UnitHandle           equ 'UH'                ; since we only have one unit
                                                ; it is check-only.

init_done               db false
allocated               db false
                        Public init_done,allocated


behave_as_a_floppy      db false
                        Public behave_as_a_floppy

lockstate               dw 0
                        Public lockstate

MyAdapterInfo           ADAPTERINFO <>
changed_unitinfo_ptr    dd 0
                        Public MyAdapterInfo,changed_unitinfo_ptr

data_end                label byte

;********************************************************************

                        include resmgrd.inc
                        include resmgrdi.inc

                        ;  '12345678901234567'
MyAdapterName           db 'mem disk adapter',0

                        ;   1234567890123456
ADD_Name                db 'virtual Harddisk',0
ADD_Name_removable      db 'virtual removable disk',0

Message_table           dw 1178 ; "%1"  ; message number
                        dw 1            ; one paramter
fillin_string_ofs       dw ?            ; first fill in item
                        dw data

Message_title           db 'MemDisk * Veit Kannegieser * 2001.12.22 .. ',datum,0
Message_BIOS_not_found  db 'BIOS filter code not found.',0
Message_bios_data_error db 'BIOS MemDisk data block is invalid.',0
Message_GDT             db 'GDT error.',0
Message_Register        db 'RegisterDeviceClass failed.',0
Message_physaddr        db 'Physical Address of Memory Disk is '
  Message_physaddr_addr db 'xxxxxxxx',0
Message_cmdline_error   db 'usage: BASEDEV=MemDisk.ADD [/Q|/V]',13,10
                        db '  /Q|V .. quiet and verbose message mode.',13,10,0

p_Disk_Config_Table     dd ?
l_Disk_Config_Table     dw ?
                        Public p_Disk_Config_Table,l_Disk_Config_Table

quiet                   db true
                        Public quiet

data                    Ends

;********************************************************************

code                    Segment
                        assume cs:code
                        assume ds:data

;様様様様様様様様様様様様様様様様様様様様様様様様様様様様様様様様様様

a_proc                  DeviceHelper
                        call [Device_Help]

                      ; jnc @@exit
                      ; i n t  3
  @@exit:
                        ret
a_endp                  DeviceHelper

;様様様様様様様様様様様様様様様様様様様様様様様様様様様様様様様様様様

a_proc                  memdisk_strategy
                        pushad

                        ; error,unknown command
                        mov ax,08003h

                        ; basedev init command ?
                        cmp es:RequestBlock[bx].Command_Code,CMDInitBase
                        jne @@not_init

                        ; double check
                        cmp [init_done],true
                        je @@not_init

                        ; install
                        call do_init
                        mov es:RequestBlock[bx].Data_1,0
                        and es:RequestBlock[bx].Pointer_2,0
                       ;jmp @@strat_done
  @@not_init:
                        ;cmp es:RequestBlock[bx].Command_Code,CMDGetDevSupport
                        ; note: we do not support EDDI "STRAT2"
                        ; makes not sense since we immedialtely process any request
  @@strat_done:
                        ; done.
                        or  ax,00100h
                        mov es:RequestBlock[bx].Request_Packet_Status,ax

                        popad
                        retf
a_endp                  memdisk_strategy

;様様様様様様様様様様様様様様様様様様様様様様様様様様様様様様様様様様
; DX:AX->FLAT:EAX
a_proc                  SelectorToFlat
                        push esi
                        push dx

                        movzx esi,ax    ; Offset
                        mov ax,dx       ; Selector
                        mov dl,DevHlp_VirtToLin
                        call DeviceHelper

                        pop dx
                        pop esi
                        ret
a_endp                  SelectorToFlat
;様様様様様様様様様様様様様様様様様様様様様様様様様様様様様様様様様様
; 栩栩栩栩栩栩栩栩栩栩栩栩栩栩栩栩栩栩栩栩栩栩栩栩栩栩栩栩栩栩栩栩栩

a_proc                  ADD_functionhandler

                        push bp
                          mov bp,sp

                          push fs               ;\ set to
                            push bx             ;/   IORB
                              push di           ;>   subfunction
                                push ds         ;>   data16

                                  mov bx,data
                                  mov ds,bx

                                  lfs bx,[bp+2+4]
  @@funcion_loop:
                                  ; assume no error, then check..
                                  mov fs:IORBH[bx].IOH_Status,0
                                  mov fs:IORBH[bx].IOH_ErrorCode,0

                                  ; valid command code ?
                                  mov di,fs:IORBH[bx].IOH_CommandCode
                                  cmp di,CommandCode_High
                                  ja @@invalid_CommandCode

                                  ; IOCC_CONFIGURATION does not need an unithandle
                                  cmp di,IOCC_CONFIGURATION
                                  je @@accept_unithandle
                                  cmp fs:IORBH[bx].IOH_UnitHandle,my_UnitHandle
                                  je @@accept_unithandle

                                  ; wrong IOH_UnitHandle
                                  mov fs:IORBH[bx].IOH_Status,IORB_ERROR
                                  mov fs:IORBH[bx].IOH_ErrorCode,IOERR_CMD_SYNTAX
                                  jmp @@not_unknown_command
  @@accept_unithandle:
                                  ; for IOCC_GEOMETRY..IOCC_RESOURCE the unit must be allocated
                                  cmp di,IOCC_GEOMETRY
                                  jnae @@no_not_allocated_error
                                  cmp allocated,true
                                  je @@no_not_allocated_error

  @@no_not_allocated_error:
                                  ; call command handler
                                  shl di,1
                                  call CommandCode[di]
                                  jmp @@not_unknown_command
  @@invalid_CommandCode:
                                  call function_unknown
  @@not_unknown_command:
                                  ; one request elemenent is done
                                  or fs:IORBH[bx].IOH_Status,IORB_DONE


                                  ; save the pointer to the next IORB
                                  ; since after calling the notify procedure,
                                  ; the IORB is no longer valid.

                                  sub ax,ax
                                  sub di,di
                                  ; chained request?
                                  test fs:IORBH[bx].IOH_RequestControl,IORB_CHAIN
                                  jz @@no_pNxtIORB

                                  mov di,fs:IORBH[bx].IOH_pNxtIORB.offs
                                  mov ax,fs:IORBH[bx].IOH_pNxtIORB.sel
  @@no_pNxtIORB:

                                  ; should completion callback called ?
                                  test fs:IORBH[bx].IOH_RequestControl,IORB_ASYNC_POST
                                  jz @@no_completion_callback

                                  pushad
                                  push gs
                                  push fs

                                    push fs
                                    push bx
                                    call fs:IORBH[bx].IOH_NotifyAddress
                                    add sp,4

                                  pop fs
                                  pop gs
                                  popad

  @@no_completion_callback:
                                  ; chained request? (ax:di)
                                  test ax,ax
                                  jz @@function_exit    ; no.

                                  ; load+process it
                                  mov fs,ax
                                  mov bx,di
                                  jmp @@funcion_loop
  @@function_exit:

                                pop ds
                              pop di
                            pop bx
                          pop fs

                        pop bp
                        retf
a_endp                  ADD_functionhandler

;様様様様様様様様様様様様様様様様様様様様様様様様様様様様様様様様様様

a_proc                  function_unknown
                        mov fs:IORBH[bx].IOH_Status   ,IORB_ERROR
                        mov fs:IORBH[bx].IOH_ErrorCode,IOERR_CMD_NOT_SUPPORTED
                        ret
a_endp                  function_unknown

;様様様様様様様様様様様様様様様様様様様様様様様様様様様様様様様様様様

;a_proc                 function_do_nothing
;                       ; error code and flag is already cleared
;                       ret
;a_endp                 function_do_nothing

;様様様様様様様様様様様様様様様様様様様様様様様様様様様様様様様様様様

a_proc                  function_CONFIGURATION
                        pushad

                        mov ax,fs:IORBH[bx].IOH_CommandModifier
                        cmp ax,IOCM_COMPLETE_INIT
                        je @@exit                       ; succesful

                        cmp ax,IOCM_GET_DEVICE_TABLE
                        jne @@not_IOCM_GET_DEVICE_TABLE

                        les di,fs:IORB_CONFIGURATION[bx].IOCFG_pDeviceTable
                        mov es:DEVICETABLE[di].IODT_ADDLevelMajor,ADD_LEVEL_MAJOR
                        mov es:DEVICETABLE[di].IODT_ADDLevelMinor,ADD_LEVEL_MINOR
                        mov ax,[ADDDHandle]
                        mov es:DEVICETABLE[di].IODT_ADDHandle,ax
                        mov es:DEVICETABLE[di].IODT_TotalAdapters,1
                        lea ax,[di+Size DEVICETABLE]
                        mov es:DEVICETABLE[di].IODT_pAdapter,ax

                        ; copy adapterinfo/unitinfo
                        mov di,ax
                        mov si,Offset MyAdapterInfo
                        mov cx,Size MyAdapterInfo
                        cld
                        rep movsb

                        ; filter/DD updated unitinfo?
                        cmp changed_unitinfo_ptr,0
                        je @@ignore_changed_unitinfo_ptr

                        push ds
                          lds si,changed_unitinfo_ptr
                          mov cx,Size UNITINFO
                          sub di,cx
                          rep movsb
                        pop ds

  @@ignore_changed_unitinfo_ptr:
                        jmp @@exit                      ; successful

  @@not_IOCM_GET_DEVICE_TABLE:
                        call function_unknown           ; unknown

  @@exit:
                        popad
                        ret
a_endp                  function_CONFIGURATION

;様様様様様様様様様様様様様様様様様様様様様様様様様様様様様様様様様様

a_proc                  function_UNIT_CONTROL
                        pushad

                        mov di,fs:IORBH[bx].IOH_CommandModifier
                        cmp di,IOCM_ALLOCATE_UNIT
                        jne @@not_IOCM_ALLOCATE_UNIT

                        cmp [allocated],true
                        je @@unit_already_allocated

                        mov [allocated],true
                        jmp @@exit                      ; successful

  @@unit_already_allocated:
                        mov fs:IORBH[bx].IOH_Status,IORB_ERROR
                        mov fs:IORBH[bx].IOH_ErrorCode,IOERR_UNIT_ALLOCATED
                        jmp @@exit                      ; error


  @@not_IOCM_ALLOCATE_UNIT:
                        cmp di,IOCM_DEALLOCATE_UNIT
                        jne @@not_IOCM_DEALLOCATE_UNIT

                        cmp [allocated],false
                        je @@unit_not_allocated

                        mov [allocated],false
                        jmp @@exit                      ; successful
  @@unit_not_allocated:
                        mov fs:IORBH[bx].IOH_Status,IORB_ERROR
                        mov fs:IORBH[bx].IOH_ErrorCode,IOERR_UNIT_NOT_ALLOCATED
                        jmp @@exit                      ; failed

  @@not_IOCM_DEALLOCATE_UNIT:
                        cmp di,IOCM_CHANGE_UNITINFO
                        jne @@not_IOCM_CHANGE_UNITINFO

                        cmp fs:IORB_UNIT_CONTROL[bx].IOUC_UnitInfoLen,Size UNITINFO
                        je @@validsize_IOCM_CHANGE_UNITINFO

                        mov fs:IORBH[bx].IOH_Status,IORB_ERROR
                        mov fs:IORBH[bx].IOH_ErrorCode,IOERR_CMD_SYNTAX
                        jmp @@exit                      ; failed

  @@validsize_IOCM_CHANGE_UNITINFO:
                        ; not update our unitinfo table, just copy the pointer
                        mov eax,fs:IORB_UNIT_CONTROL[bx].IOUC_pUnitInfo
                        mov changed_unitinfo_ptr,eax
                        jmp @@exit                      ; successful

  @@not_IOCM_CHANGE_UNITINFO:
                        call function_unknown           ; unknown
  @@exit:
                        popad
                        ret
a_endp                  function_UNIT_CONTROL

;様様様様様様様様様様様様様様様様様様様様様様様様様様様様様様様様様様

a_proc                  function_GEOMETRY
                        pushad
                          mov di,fs:IORBH[bx].IOH_CommandModifier
                          cmp di,IOCM_GET_MEDIA_GEOMETRY
                          je @@function_IOCM_GET_x_GEOMETRY
                          cmp di,IOCM_GET_DEVICE_GEOMETRY
                          je @@function_IOCM_GET_x_GEOMETRY

                          call function_unknown
                          jmp @@exit                    ; unknown

  @@function_IOCM_GET_x_GEOMETRY:
                          les di,fs:IORB_GEOMETRY[bx].IOGG_pGeometry
                          mov eax,ds:anzahl_sektoren
                          mov es:GEOMETRY[di].IOG_TotalSectors,eax
                          mov es:GEOMETRY[di].IOG_BytesPerSector,512
                          mov es:GEOMETRY[di].IOG_Reserved,0
                          mov ax,word ptr ds:anzahl_koepfe
                          mov es:GEOMETRY[di].IOG_NumHeads,ax
                          mov eax,ds:anzahl_zylinder
                          mov es:GEOMETRY[di].IOG_TotalCylinders,eax
                          mov ax,word ptr ds:anzahl_sektoren_je_spur
                          mov es:GEOMETRY[di].IOG_SectorsPerTrack,ax

                                                        ; successful
  @@exit:

                        popad
                        ret
a_endp                  function_GEOMETRY

;様様様様様様様様様様様様様様様様様様様様様様様様様様様様様様様様様様


a_proc                  function_EXECUTE_IO
                        push gs
                        pushad

                          cmp fs:IORB_EXECUTEIO[bx].IOXIO_BlockSize,512
                          je @@IOXIO_BlockSize_512

  @@parametererror_EXECUTE_IO__REQ_NOT_SUPPORTED:
                          mov fs:IORBH[bx].IOH_Status,IORB_ERROR
                          mov fs:IORBH[bx].IOH_ErrorCode,IOERR_ADAPTER_REQ_NOT_SUPPORTED
                          jmp @@exit                    ; failed
  @@IOXIO_BlockSize_512:
                          mov cx,fs:IORB_EXECUTEIO[bx].IOXIO_cSGList
                          jcxz @@parametererror_EXECUTE_IO__SGLIST_BAD

                          lgs di,fs:IORB_EXECUTEIO[bx].IOXIO_pSGList
                          call CHS_to_RBA
                          cmp edx,ds:anzahl_sektoren
                          jae @@parametererror_EXECUTE_IO__RBA_LIMIT
                          movzx eax,fs:IORB_EXECUTEIO[bx].IOXIO_BlockCount
                          cmp eax,010000h/512           ; 64 KB
                          ja @@parametererror_EXECUTE_IO__REQ_NOT_SUPPORTED

                          call SetupDiskPosition
                          add edx,eax
                          cmp edx,anzahl_sektoren
                          jbe @@not_above_RBA_LIMIT

  @@parametererror_EXECUTE_IO__RBA_LIMIT:
                          mov fs:IORBH[bx].IOH_Status,IORB_ERROR
                          mov fs:IORBH[bx].IOH_ErrorCode,IOERR_RBA_LIMIT
                          jmp @@exit                    ; failed
  @@not_above_RBA_LIMIT:

  @@loop_EXECUTE_IO:      ;******************************************

                          mov eax,gs:SCATGATENTRY[di].IOSG_XferBufLen
                          test eax,eax
                          jz @@parametererror_EXECUTE_IO__SGLIST_BAD
                          test eax,511
                          jz @@not_SGLIST_BAD

  @@parametererror_EXECUTE_IO__SGLIST_BAD:
                          mov fs:IORBH[bx].IOH_Status,IORB_ERROR
                          mov fs:IORBH[bx].IOH_ErrorCode,IOERR_CMD_SGLIST_BAD
                          jmp @@exit                    ; failed

  @@not_SGLIST_BAD:
                          call setup_DMD_selector
                          call setup_Disk_selector


                          ; call subcomand handler
                          mov ax,fs:IORBH[bx].IOH_CommandModifier
                          cmp ax,EXECUTE_IO_High
                          jbe @@valid_modifier

                          call function_unknown
                          jmp @@exit                    ; unknown

  @@valid_modifier:
                          shl ax,1
                          xchg ax,di
                          call EXECUTE_IO[di]
                          xchg ax,di

                          mov eax,gs:SCATGATENTRY[di].IOSG_XferBufLen
                          add di,Size SCATGATENTRY
                          add fs:IORBH[bx].IOH_ADDWorkSpace.memdisk_add_workspace.disk_position,eax
                          shr eax,9                     ; /512
                          add fs:IORB_EXECUTEIO[bx].IOXIO_BlocksXferred,ax
                          loop @@loop_EXECUTE_IO
                                                        ; successful
  @@exit:
                        popad
                        pop gs
                        ret
a_endp                  function_EXECUTE_IO

;陳陳陳陳陳陳陳陳陳陳陳陳陳陳陳陳陳陳陳陳陳陳陳陳陳陳陳陳陳陳陳陳陳陳

                        ; setup dmd selector to gs:di SGLIST entry

a_proc                  setup_DMD_selector
                        pushad

                          mov ecx,gs:SCATGATENTRY[di].IOSG_XferBufLen

                          mov ax,di
                          mov dx,gs
                          call SelectorToFlat
                          mov edi,eax           ; PageList

                          mov ax,[dmd_GDT]      ; Selector
                          mov dh,6              ; ring 0 data
                          mov dl,DevHlp_PageListToGDTSelector
                          call DeviceHelper

                        popad
                        ret
a_endp                  setup_DMD_selector

;陳陳陳陳陳陳陳陳陳陳陳陳陳陳陳陳陳陳陳陳陳陳陳陳陳陳陳陳陳陳陳陳陳陳
; edx=CHS/RBA -> RBA
; fs:[bx]=IORB_EXECUTEIO
; ds=data
a_proc                  CHS_to_RBA
                        mov edx,fs:IORB_EXECUTEIO[bx].IOXIO_RBA
                        ; convert any CHS requests
                        test fs:IORBH[bx].IOH_RequestControl,IORB_CHS_ADDRESSING
                        jz @@exit

                        push eax
                          movzx eax,fs:IORB_EXECUTEIO[bx].IOXIO_RBA.CHS_ADDR.IOCHS_Cylinder
                          mov edx,ds:anzahl_koepfe
                          mul edx
                          movzx edx,fs:IORB_EXECUTEIO[bx].IOXIO_RBA.CHS_ADDR.IOCHS_Head
                          add eax,edx
                          mov edx,anzahl_sektoren_je_spur
                          mul edx
                          movzx edx,fs:IORB_EXECUTEIO[bx].IOXIO_RBA.CHS_ADDR.IOCHS_Sector
                          lea edx,[eax+edx-1]
                        pop eax
  @@exit:
                        ret
a_endp                  CHS_to_RBA
;陳陳陳陳陳陳陳陳陳陳陳陳陳陳陳陳陳陳陳陳陳陳陳陳陳陳陳陳陳陳陳陳陳陳
; fs:bx=IORB_EXECUTEIO
; edx=RBA
a_proc                  SetupDiskPosition
                        push edx
                          shl edx,9             ; *512
                          add edx,[physical_address]
                          mov fs:IORBH[bx].IOH_ADDWorkSpace.memdisk_add_workspace.disk_position,edx
                        pop edx
                        ret
a_endp                  SetupDiskPosition

;陳陳陳陳陳陳陳陳陳陳陳陳陳陳陳陳陳陳陳陳陳陳陳陳陳陳陳陳陳陳陳陳陳陳
; fs:bx=IORB_EXECUTEIO
; gs:di=SGLIST entry

a_proc                  setup_Disk_selector
                        pushad
                          ; ax:bx
                          mov eax,fs:IORBH[bx].IOH_ADDWorkSpace.memdisk_add_workspace.disk_position
                          mov bx,ax
                          shr eax,16
                          ; cx,0=64K
                          mov ecx,gs:SCATGATENTRY[di].IOSG_XferBufLen
                          mov si,[disk_GDT]     ; selector
                          mov dl,DevHlp_PhysToGDTSelector
                          call DeviceHelper
                        popad
                        ret
a_endp                  setup_Disk_selector
;陳陳陳陳陳陳陳陳陳陳陳陳陳陳陳陳陳陳陳陳陳陳陳陳陳陳陳陳陳陳陳陳陳陳

a_proc                  function_READ
                        xchg ax,di
                        push ds
                        push es
                        pushad

                          ; length
                          mov ecx,gs:SCATGATENTRY[di].IOSG_XferBufLen

                          ; Target
                          mov es,[dmd_GDT]
                          sub edi,edi

                          ; Source
                          mov ds,[disk_GDT]
                          sub esi,esi

                          ; copy 32 bit blocks
                          shr ecx,2

                          cld
                          rep movs Dword Ptr es:[edi],[esi]

                        popad
                        pop es
                        pop ds
                        xchg ax,di
                        ret
a_endp                  function_READ

;陳陳陳陳陳陳陳陳陳陳陳陳陳陳陳陳陳陳陳陳陳陳陳陳陳陳陳陳陳陳陳陳陳陳

a_proc                  function_VERIFY
                        ret
a_endp                  function_VERIFY

;陳陳陳陳陳陳陳陳陳陳陳陳陳陳陳陳陳陳陳陳陳陳陳陳陳陳陳陳陳陳陳陳陳陳

a_proc                  function_WRITE
                        xchg ax,di
                        push ds
                        push es
                        pushad

                          ; length
                          mov ecx,gs:SCATGATENTRY[di].IOSG_XferBufLen

                          ; Target
                          mov es,[disk_GDT]
                          sub edi,edi

                          ; Source
                          mov ds,[dmd_GDT]
                          sub esi,esi

                          ; copy 32 bit blocks
                          shr ecx,2

                          cld
                          rep movs Dword Ptr es:[edi],[esi]

                        popad
                        pop es
                        pop ds
                        xchg ax,di
                        ret
a_endp                  function_WRITE

;様様様様様様様様様様様様様様様様様様様様様様様様様様様様様様様様様様

a_proc                  function_UNIT_STATUS
                        push di

                          mov di,fs:IORBH[bx].IOH_CommandModifier
                          cmp di,IOCM_GET_UNIT_STATUS
                          jne @@not_IOCM_GET_UNIT_STATUS

                          mov fs:[bx].IORB_UNIT_STATUS.IOUS_UnitStatus,US_READY
                          jmp @@exit                    ; successful

  @@not_IOCM_GET_UNIT_STATUS:
                          cmp di,IOCM_GET_CHANGELINE_STATE
                          jne @@not_IOCM_GET_CHANGELINE_STATE
                          cmp behave_as_a_floppy,true
                          jne @@not_IOCM_GET_CHANGELINE_STATE

                          ; US_CHANGELINE_ACTIVE not set
                          mov fs:[bx].IORB_UNIT_STATUS.IOUS_UnitStatus,0
                          jmp @@exit                    ; successful

  @@not_IOCM_GET_CHANGELINE_STATE:
                          cmp di,IOCM_GET_MEDIA_SENSE
                          jne @@not_IOCM_GET_MEDIA_SENSE

                          ; only respond when in floppy mode
                          cmp behave_as_a_floppy,true
                          jne @@exit_UNIT_STATUS_function_unknown
                          ; largest value seem to be 2.8M
                          mov fs:[bx].IORB_UNIT_STATUS.IOUS_UnitStatus,US_MEDIA_288MB
                          jmp @@exit                    ; successful

  @@not_IOCM_GET_MEDIA_SENSE:
                          cmp di,IOCM_GET_LOCK_STATUS
                          jne @@not_IOCM_GET_LOCK_STATUS

                          push lockstate
                          pop fs:[bx].IORB_UNIT_STATUS.IOUS_UnitStatus
                          jmp @@exit                    ; successful

  @@not_IOCM_GET_LOCK_STATUS:
  @@exit_UNIT_STATUS_function_unknown:
                          call function_unknown         ; unknown
  @@exit:
                        pop di
                        ret
a_endp                  function_UNIT_STATUS

;様様様様様様様様様様様様様様様様様様様様様様様様様様様様様様様様様様

a_proc                  function_DEVICE_CONTROL
                        push di

                          mov di,fs:IORBH[bx].IOH_CommandModifier

                        ; IOCM_ABORT   - SCSI
                        ; IOCM_RESET   - SCSI
                        ; IOCM_SUSPEND - floppy
                        ; IOCM_RESUME  - floppy

                          cmp di,IOCM_LOCK_MEDIA
                          jne @@not_IOCM_LOCK_MEDIA
                          or lockstate,US_LOCKED
                          jmp @@exit                    ; successful
  @@not_IOCM_LOCK_MEDIA:

                          cmp di,IOCM_UNLOCK_MEDIA
                          jne @@not_IOCM_UNLOCK_MEDIA
                          and lockstate,(not US_LOCKED)
                          jmp @@exit                    ; successful
  @@not_IOCM_UNLOCK_MEDIA:

                          cmp di,IOCM_EJECT_MEDIA
                          jne @@not_IOCM_EJECT_MEDIA
                          ; 'success', if not locked??
                          ; test lockstate,US_LOCKED??
                          mov fs:IORBH[bx].IOH_Status,IORB_ERROR
                          mov fs:IORBH[bx].IOH_ErrorCode,IOERR_DEVICE_REQ_NOT_SUPPORTED
                          jmp @@exit                    ; failed
  @@not_IOCM_EJECT_MEDIA:

                          call function_unknown
  @@exit:
                        pop di
                        ret
a_endp                  function_DEVICE_CONTROL

;様様様様様様様様様様様様様様様様様様様様様様様様様様様様様様様様様様

code_end:

                        include rmcall.inc
                        include rmcdrvr.inc

;様様様様様様様様様様様様様様様様様様様様様様様様様様様様様様様様様様

                        ; ES:BX=Init packet
                        ; Output ax=return code
                        ; other registers altered...
a_proc                  do_init

                        mov eax,es:RequestBlock[bx].Pointer_1
                        mov Device_Help,eax

                        call RegisterResourceManager

                        push es
                        push bx

                          ; look for switches
                          les bx,es:RequestBlock[bx].Pointer_2
                          mov ax,es:[bx].Init_Arguments.Disk_Config_Table
                          mov p_Disk_Config_Table.offs,ax
                          mov p_Disk_Config_Table.sel ,es
                          mov ax,es:[bx].Init_Arguments.Machine_Config_Table
                          mov l_Disk_Config_Table,ax
                          mov bx,es:[bx].Init_Arguments.Cmd_Line_Args


                          mov si,Offset Message_cmdline_error
  @@loop_skip_drivername:
                          mov al,es:[bx]
                          inc bx
                          cmp al,0
                          je @@commandline_done
                          cmp al,' '
                          ja @@loop_skip_drivername

                          dec bx

  @@next_commandlinechar:
                          mov al,es:[bx]
                          inc bx

                          cmp al,0
                          je @@commandline_done

                          cmp al,' '
                          jbe @@next_commandlinechar

                          cmp al,'-'
                          je @@command_switch
                          cmp al,'/'
                          jne @@install_failed

  @@command_switch:
                          mov al,es:[bx]
                          inc bx

                          cmp al,'1'
                          jne @@not_switch_1

                          ; was previously an option to not patch _VDMINT10CreateMiniVDMSub
                          ; that patch code is now  moved to pmvdmcc.sys
                          jmp @@next_commandlinechar
  @@not_switch_1:
                          cmp al,'Q'
                          je @@switch_q
                          cmp al,'q'
                          jne @@not_switch_q
  @@switch_q:
                          mov quiet,true
                          jmp @@next_commandlinechar
  @@not_switch_q:
                          cmp al,'V'
                          je @@switch_v
                          cmp al,'v'
                          jne @@install_failed
  @@switch_v:
                          mov quiet,false
                          jmp @@next_commandlinechar

  @@commandline_done:

                          mov si,Offset Message_title
                          call Display_Message

                          ; Allocate 1 selector
                          push ds
                          pop es
                          mov di,Offset disk_GDT
                          mov cx,1
                          mov dl,DevHlp_AllocGDTSelector
                          call DeviceHelper
                          jc @@gdt_allocation_failed

                          ; search BIOS memdisk code
                          push 00040h
                          pop es
                          movzx edx,word ptr es:[00013h] ; end 640K memory
                          shl edx,10 ; 639 -> $9fc00

  @@look_for_bios_memdisk:
                          ; look until A000:0
                          mov ecx,0a0000h-Size MemDiskBIOS_Info_Block
                          sub ecx,edx
                          jbe @@no_bios_disk_found
                          mov eax,1024
                          cmp ecx,eax
                          if_a <mov ecx,eax>

                          ; make ax:bx accessible
                          push edx
                          push cx
                            mov eax,edx
                            mov bx,ax
                            shr eax,16
                            add cx,Size MemDiskBIOS_Info_Block
                            mov si,[disk_GDT]           ; selector
                            mov dl,DevHlp_PhysToGDTSelector
                            call DeviceHelper
                          pop cx
                          pop edx
                          jc @@no_bios_disk_found

                          mov es,[disk_GDT]
                          sub di,di
  @@search_bios_memdisk1_loop:
                          cmp es:[di]._MDBIB_sign0,_MDBIB_sign0_val
                          jne @@not_bios_memdisk1
                          cmp es:[di]._MDBIB_sign1,_MDBIB_sign1_val
                          je @@found_bios_memdisk
  @@not_bios_memdisk1:
                          inc di
                          inc edx
                          loop @@search_bios_memdisk1_loop
  @@not_bios_memdisk:
                          jmp @@look_for_bios_memdisk

  @@found_bios_memdisk:
                          ; have information record at es:[di]..

                          ; LVM (default Z:) or Warp4 A:/B: mode?
                          cmp es:[di].MemDiskBIOS_Info_Block._lvm_letter,'C'
                          setb behave_as_a_floppy

                          ; use physical address of disk memory
                          mov eax,es:[di].MemDiskBIOS_Info_Block._phys_addr
                          mov physical_address,eax
                          mov MemBase1,eax

                          mov eax,es:[di].MemDiskBIOS_Info_Block._anzahl_zylinder
                          cmp eax,1
                          jb @@memdisk_bios_data_error
                          cmp eax,1024
                          ja @@memdisk_bios_data_error
                          mov anzahl_zylinder,eax

                          mov eax,es:[di].MemDiskBIOS_Info_Block._anzahl_koepfe
                          cmp eax,1
                          jb @@memdisk_bios_data_error
                          cmp eax,255
                          ja @@memdisk_bios_data_error
                          mov anzahl_koepfe,eax

                          mov eax,es:[di].MemDiskBIOS_Info_Block._anzahl_sektoren_je_spur
                          cmp eax,1
                          jb @@memdisk_bios_data_error
                          cmp eax,63
                          ja @@memdisk_bios_data_error
                          mov anzahl_sektoren_je_spur,eax

                          mov edx,anzahl_koepfe
                          mul edx
                          mov edx,anzahl_zylinder
                          mul edx
                          test edx,edx
                          jnz @@memdisk_bios_data_error
                          cmp eax,es:[di].MemDiskBIOS_Info_Block._anzahl_sektoren
                          jne @@memdisk_bios_data_error
                          mov anzahl_sektoren,eax

                          shl eax,9                     ; *512
                          mov MemSize1,eax

                          ; Allocate 1 selector
                          push ds
                          pop es
                          mov di,Offset dmd_GDT
                          mov cx,1
                          mov dl,DevHlp_AllocGDTSelector
                          call DeviceHelper
                          jc @@gdt_allocation_failed

                          mov si,Offset ADD_Name
                          cmp behave_as_a_floppy,true
                          if_e <mov si,Offset ADD_Name_removable>
                          mov ax,cs
                          mov bx,Offset ADD_functionhandler
                          mov di,0                        ; device flags
                          mov cx,1                        ; device class
                          mov dl,DevHlp_RegisterDeviceClass
                          call DeviceHelper
                          jc @@RegisterDeviceClass_failed
                          mov [ADDDHandle],ax

                          mov [init_done],true

                          cmp behave_as_a_floppy,true
                          jne @@not_need_to_hide_drives_from_ibm1flpy_add

                          ; shift floppy drive numbers back from 1..n to 0..n-1 for ibm1flpy.add
                          les di,p_Disk_Config_Table
  @@loop_hide_drives_from_ibm1flpy_add:
                          cmp di,l_Disk_Config_Table
                          jae @@not_need_to_hide_drives_from_ibm1flpy_add

                          test es:[di].ROMdevnbr,080h
                          jnz @@not_floppy_00_7f

                          dec es:[di].ROMdevnbr
                          and es:[di].ROMdevnbr,07fh
  @@not_floppy_00_7f:
                          mov di,es:[di].ROMlink
                          test di,di
                          jnz @@loop_hide_drives_from_ibm1flpy_add

  @@not_need_to_hide_drives_from_ibm1flpy_add:

                        pop bx
                        pop es

                        mov di,Offset Message_physaddr_addr
                        mov eax,physical_address
                        mov cx,8
  @@IntToHex:
                        rol eax,4
                        push ax
                          and al,00fh
                          cmp al,10
                          sbb al,69h
                          das
                          mov ds:[di],al
                          inc di
                        pop ax
                        loop @@IntToHex

                        mov si,Offset Message_physaddr
                        call Display_Message

                        call RegisterResourceManagerAdapter

                        call SetupMyAdapterInfo

                        ; reduce resident data/code size
                        mov es:RequestBlock[bx].Pointer_1.WORD1616.Lo,Offset code_end
                        mov es:RequestBlock[bx].Pointer_1.WORD1616.Hi,Offset data_end
                        sub ax,ax                       ; no error
                        jmp @@exit__do_init

  @@no_bios_disk_found:
                          mov si,Offset Message_BIOS_not_found
                          jmp @@install_failed

  @@memdisk_bios_data_error:
                          mov si,Offset Message_bios_data_error
                          jmp @@install_failed
  @@gdt_allocation_failed:
                          mov si,Offset Message_GDT
                          jmp @@install_failed

  @@RegisterDeviceClass_failed:
                          mov si,Offset Message_Register
  @@install_failed:
                          call Display_Message
                        pop bx
                        pop es

                        ; free GDT resources

                        mov ax,disk_GDT
                        mov dl,DevHlp_FreeGDTSelector
                        test ax,ax
                        if_nz < call DeviceHelper >

                        mov ax,dmd_GDT
                        mov dl,DevHlp_FreeGDTSelector
                        test ax,ax
                        if_nz < call DeviceHelper >

                        push es
                        pushad
                          push hDriver
                          CallRM RMDestroyDriver
                          add sp,4
                        popad
                        pop es

                        ; not installed, no message
                        mov es:RequestBlock[bx].Pointer_1,0
                        mov ax,08015h
  @@exit__do_init:
                        ret
a_endp                  do_init

;陳陳陳陳陳陳陳陳陳陳陳陳陳陳陳陳陳陳陳陳陳陳陳陳陳陳陳陳陳陳陳陳陳陳

a_proc                  SetupMyAdapterInfo
                        push es
                        pusha

                          push ds
                          pop es

                          cld

                          ; adapterinfo

                          mov di,Offset MyAdapterInfo
                          push di
                            add di,Offset IOAI_AdapterName
                            mov si,Offset MyAdapterName
                            mov cx,Size ADAPTERINFO.IOAI_AdapterName
  @@CopyMyAdapterNameLoop:
                            lodsb
                            stosb
                            dec cx
                            cmp al,0
                            jne @@CopyMyAdapterNameLoop
                            rep stosb
                          pop di

                          mov [di].ADAPTERINFO.IOAI_Reserved,0
                          mov [di].ADAPTERINFO.IOAI_AdapterUnits,1
                          mov [di].ADAPTERINFO.IOAI_AdapterDevBus,AI_DEVBUS_OTHER+AI_DEVBUS_32BIT
                          mov [di].ADAPTERINFO.IOAI_AdapterIOAccess,AI_IOACCESS_MEMORY_MAP
                          mov [di].ADAPTERINFO.IOAI_AdapterHostBus,AI_HOSTBUS_UNKNOWN+AI_BUSWIDTH_UNKNOWN
                          mov [di].ADAPTERINFO.IOAI_AdapterSCSITargetID,0
                          mov [di].ADAPTERINFO.IOAI_AdapterSCSILUN,0
                          mov [di].ADAPTERINFO.IOAI_AdapterFlags,AF_16M
                        ;? cmp behave_as_a_floppy,true
                        ;? if_e <or [di].ADAPTERINFO.IOAI_AdapterFlags,AF_CHS_ADDRESSING>
                          mov [di].ADAPTERINFO.IOAI_MaxHWSGList,1
                          mov [di].ADAPTERINFO.IOAI_MaxCDBTransferLength,0

                          add di,Offset ADAPTERINFO.IOAI_UnitInfo

                          ; unitinfo
                          mov [di].UNITINFO.IOUI_AdapterIndex,0 ; zero based?
                          mov [di].UNITINFO.IOUI_UnitIndex,0    ; zero based?
                          mov [di].UNITINFO.IOUI_UnitFlags,UF_NOSCSI_SUPT
                          cmp behave_as_a_floppy,true
                          if_e <or [di].UNITINFO.IOUI_UnitFlags,(UF_REMOVABLE or UF_CHANGELINE or UF_A_DRIVE)>
                          mov [di].UNITINFO.IOUI_Reserved,0
                          mov [di].UNITINFO.IOUI_UnitHandle,my_UnitHandle
                          mov [di].UNITINFO.IOUI_FilterADDHandle,0
                          mov [di].UNITINFO.IOUI_UnitType,UIB_TYPE_DISK
                          mov [di].UNITINFO.IOUI_QueuingCount,1
                          mov [di].UNITINFO.IOUI_UnitSCSITargetID,0
                          mov [di].UNITINFO.IOUI_UnitSCSILUN,0

                        popa
                        pop es
                        ret
a_endp                  SetupMyAdapterInfo

;陳陳陳陳陳陳陳陳陳陳陳陳陳陳陳陳陳陳陳陳陳陳陳陳陳陳陳陳陳陳陳陳陳陳

                        ; data:si=string
a_proc                  Display_Message
                        cmp quiet,true
                        je @@suppress_Message_Display

                        pusha
                          push ds

                            push Seg data
                            pop ds

                            mov fillin_string_ofs,si
                            mov si,Offset Message_table
                            sub bx,bx
                            mov dl,DevHlp_Save_Message
                            call DeviceHelper

                          pop ds
                        popa

  @@suppress_Message_Display:
                        ret
a_endp                  Display_Message

;様様様様様様様様様様様様様様様様様様様様様様様様様様様様様様様様様様

a_proc                  RegisterResourceManagerAdapter
                        push es
                        pushad

                          ; tell resource usage

                          push    ds                      ; \ EXT Mem
                          push    Offset Mem_Resource1    ; / record
                          push    ds                      ; \ update EXT Mem
                          push    Offset hMem_Resource1   ; / handle
                          push    hDriver                 ; > allocated by us
                          CallRM  RMAllocResource
                          add     sp,4+4+4
                          test    ax,ax
                          jnz     @@error_ResourceManager

                          ; get a new adapter

                          push    ds                      ; \ allocate 2 handles
                          push    Offset MemResourceList  ; / (EXT and 639)
                          push    dword PTR 0             ; > get parent from hostbus field
                          push    ds                      ; \ specify the
                          push    Offset AdapterStructure ; / adapter
                          push    ds                      ; \ store handle
                          push    Offset hAdapter         ; / for adapter
                          push    hDriver                 ; > allocated by us
                          CallRM  RMCreateAdapter
                          add     sp,4+4+4+4+4
                          test    ax,ax
                          jnz     @@error_ResourceManager

                          cmp     behave_as_a_floppy,true
                          if_e    <mov [DeviceStructure].DevDescriptName.offs,Offset DevDescNameA>

                          push    DWord Ptr 0             ; > Resource list (none)
                          push    hAdapter                ; > parent adapter
                          push    ds                      ; \ specify the
                          push    Offset DeviceStructure  ; / device
                          push    ds                      ; \ store handle
                          push    Offset hDevice          ; / for device
                          push    hDriver                 ; > allocated by us
                          CallRM  RMCreateDevice
                          add     sp,4+4+4+4+4
                         ;test    ax,ax
                         ;jnz     @@error_ResourceManager

  @@error_ResourceManager:

                        popad
                        pop es
                        ret
a_endp                  RegisterResourceManagerAdapter

;様様様様様様様様様様様様様様様様様様様様様様様様様様様様様様様様様様

code                    EndS

;********************************************************************

                        End

